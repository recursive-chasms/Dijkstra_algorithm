
Dijkstra
========
1 -> 1 | 0
1 -> 2 | 2
1 -> 3 | 3
1 -> 4 | 1
1 -> 5 | 3
1 -> 6 | 6
1 -> 7 | 5

source: 1 dest: 6

1-- dist: {.,2,.,1,.,.,.}  	queue: 2,4		visited: 1
2-- dist: {.,2,.,1,12,.,.}	queue: 4,5		visited: 1,2
4-- dist: {.,2,3,1,3,9,5}	queue: 5,3,6,7	visited: 1,2,4
5-- dist: {.,2,3,1,3,9,5}	queue: 3,6,7,6	visited: 1,2,4,5
3-- dist: {.,2,3,1,3,8,5}	queue: 6,7,6,6	visited: 1,2,3,4,5
6-- dist: {.,2,3,1,3,8,5}	queue: 7,6,6	visited: 1,2,3,4,5,6
7-- dist: {.,2,3,1,3,6,5}


Primm
=====
Edge 	Weight
1 - 2    2
4 - 3    2
1 - 4    1
4 - 5    2
7 - 6    1
4 - 7    4

/*
Note: Actual route from 1 to 6:

1 -> 4 -> 7 -> 6

Supposed route: 
7 -> 6 
3 -> 5 
4 -> 5 
2 -> 4 
1 -> 2 

The nodes of the actual route exist in the output. Need to find a means of eliminating the redundant ones. Probably won't be very efficient. May help to refactor the linked lists into arrays. Maybe just removing the macros will be better, though, since it'll be easier to remove nodes. Or maybe just don't print the indices that have been blanked out. In any case, it'll probably necessitate iterating through the whole path at every turn.

Once shortest distances are finalized, just choose the shortest path at each connected node. Simple. (I think.) This is something that's done after the initial sequence--not during.

Each point in iArr_distance needs to contain a stack of predecessor nodes/distances in addition to the total distance. Every update is not only going to add to the distance. It's also going to involve removing at least one value from the stack. 

Actually, each update for the stack is going to involve copying over the entire predecessor stack. Look at the update for the distance of node 5: It goes from 12 to 3, and the entire stack is replaced. 
*/


